#!/bin/zsh

# Copyright 2015 Han Boetes <han@boetes.org>
# For license info see http://unlicense.org/

# This script plays songs, random or non-random, see the -h output for
# more help.

# Feature requests: play songs only once. make -c x work like expected

# These vars may be interesting to change by other users.
GREP="grep -i"
MEDIAPLAYER="mpv -vo null -af volume=-10 -really-quiet"
playlist="/mp3/playlist.gz"
play_queue="/mp3/queue"
play_hist="/mp3/history"
# Number of tracks to print from the history.
qhist=10
# Number of tracks in the queue to print
qfuture=20

# These variable should not have to be touched by anyone.
prog="${0:t}"
# Directory where you want to store your pidfile.
pid_dir="${TMPDIR:=/tmp}/${prog}-$(id -u)"
# Number of songs to play, unless overriden later on.
count=1
setopt no_bare_glob_qual
# Where the config file is stored.
config="~/.config/muzshic/config"

# Ugly code for portability. At least everyone knows why it's there,
# the default zcat on Darwin is broken.
OS=$(uname -s)
case $OS in
    Darwin)
        ZCAT=gzcat
        ;;
    *)
        ZCAT=zcat
        ;;
esac

if [[ -r ${~config} ]]; then
    source ${~config}
else
    print 'run genconfig to generate a configuration file.' >&2
    exit 0
fi

alnum()
{
    if [[ $1 != <-> ]]; then
        error "'$1' is not a valid integer!"
    fi
}

print_green()
{
    print '\e[32m'${1}'\e[00m'
}

print_yellow()
{
    print '\e[33m'${1}'\e[00m'
}

print_song()
{
    song_nopath="${song:t}"
    clear
    readh
    if ((${#h} > $qhist)); then
        pr=$qhist
    else
        pr=${#h}
    fi
    # XXX This prints an empty line on empty history.
    print -l ${h[-$pr,-1]:t}
    print_green $song_nopath
    h=($h $song_nopath)
    writeh
    if typeset -f local_print_song >& /dev/null; then
        local_print_song
    fi
    # Let's not print too many queued files
    print -l ${q[1,$qfuture]:t}
    qlength=${#q}
    if ((qlength > qfuture)); then
        ((rest = qlength - qfuture))
        print_yellow "And $rest more tracks."
    fi
}

# This function is executed when $0 quits.
unprint_song()
{
    if typeset -f local_print_song >& /dev/null; then
        local_unprint_song
    fi
}

warn()
{
    print "$prog: Warning: Song $song not found!?" >&2
}

error()
{
    print "$prog: $1" >&2
    exit 1
}

play_song()
{
    print_song
    # ${=foo} wordsplits a variable.
    ${=MEDIAPLAYER} "$song" || warn
}

create_pid()
{
    # First create the pid_dir in a safe way, if it doesn't exist.
    if [[ ! -d $pid_dir ]]; then
        pid_tmpdir=$(mktemp -d $pid_dir.XXXXXXXXXXXXXXXXX) || error "Can't create tmp dir."
        mv $pid_tmpdir $pid_dir || error "Can't create pid dir."
    fi

    if [[ -e $pid_dir/pid ]]; then
        error "is already running."
    else
        # And then create a pid_file
        print $$ > $pid_dir/pid
    fi
}

remove_pid()
{
    # Only remove the pidfile if it belongs to the current
    # process. This is redundant hopefully. :-}
    pid=$(< $pid_dir/pid)
    if [[ $$ == $pid ]]; then
        rm $pid_dir/pid
    fi
}

readq()
{
    if [[ ! -f $play_queue ]]; then
        error "$play_queue does not exist or isn't a regular file."
    fi
    q=("${(@f)$(< $play_queue)}") || error "Can't read $play_queue"

}

writeq()
{
    print -l $q > $play_queue || error "Can't write to ${play_queue}, check permissions."
}

# XXX Can we deduplicate this?
readh()
{
    # We'll create this file if it doesn't exist
    touch $play_hist
    if [[ ! -f $play_hist ]]; then
        error "$play_hist does not exist or isn't a regular file."
    fi
    h=("${(@f)$(< $play_hist)}") || error "Can't read $play_hist"

}

writeh()
{
    print -l $h > $play_hist || error "Can't write to ${play_hist}, check permissions."
}

queue_mode()
{
    create_pid
    while [[ -s $play_queue ]]; do
        # Keep reading the $queue_file, the user may edit it while $0 is running.
        readq
        song=${q[1]}
        q[1]=()
        writeq
        play_song
        if [[ $pause = "TRUE" ]]; then
            print -n 'Press the any key to continue '
            read -sk 1 nothing
            print
        fi
    done
    # This message only makes sense in queue mode.
    if [[ $qmode == "TRUE" ]]; then
        print "The queue is empty!"
    fi
    exit 0
}

enqueue_song()
{
    readq
    if [[ $head == "TRUE" ]]; then
        q[$headcount,0]=($song)
        ((headcount++))
    else
        q=($q $song)
    fi
    writeq
}

zshexit()
{
    if [[ $do_nothing != "TRUE" ]]; then
        unprint_song
        remove_pid
    fi
    exit
}

# Incase the program is interrupted, for example by pressing ctrl-c
# first make sure the pid file is removed etc.
TRAPINT()
{
    zshexit
}

show_help()
{
    cat << EOF
Usage: $prog -[ncaplLqxH] [grep regex]
  -n play tracks in non-random order
  -c x ; add x tracks to the queue
  -a add all tracks selected by regex.
  -p pause after each track.
  -l select regex with finetuning.
  -L = -l -a -n
  -q play all songs from $play_queue
  -x clear the queue
  -H add songs to the head of $play_queue
EOF
}

# Main
if [[ ! -f $playlist ]]; then
    error "$playlist not found. Don't forget to run mkplaylist"
fi

if [[ ! -s $playlist ]]; then
    error "$playlist is empty. Double check your config and then run mkplaylist."
fi

# Parse command line arguments
while  (($# > 0)); do
    case $1 in
        -h)
            show_help
            do_nothing="TRUE"
            exit 0
            ;;
        -q)
            # No other arguments. Just play the queue until the end.
            unset nonrandom get_list pause all
            qmode="TRUE"
            queue_mode
            ;;
        -n)
            shift 1
            nonrandom="TRUE"
            ;;
        -c)
            alnum $2
            count=$2
            shift 2
            ;;
        -p)
            pause="TRUE"
            shift 1
            ;;
        -l)
            get_list="TRUE"
            shift 1
            ;;
        -L)
            get_list="TRUE"
            all="TRUE"
            nonrandom="TRUE"
            shift 1
            ;;
        -a)
            all="TRUE"
            shift 1
            ;;
        -x)
            # Clear the queue
            : > $play_queue
            shift 1
            ;;

        -H)
            head="TRUE"
            headcount=1
            shift 1
            ;;
        -*)
            print "Unknown option: $1" >&2
            show_help
            do_nothing="TRUE"
            exit 1
            ;;
        *)
            # Handle input regex below.
            break
            ;;
    esac
done

# What are we going to play?
searchstring="$*"

# This is a bit of zsh magic: array=("${(@f)$(command)}") it ensures a
# list of filenames with spaces and special chars is turned into a proper array.
allfiles=("${(@f)$($ZCAT $playlist)}")

# A regex has been given and we can refine that regex and see the
# results.
if [[ $get_list == "TRUE" ]]; then
    while :; do
        if [[ $searchstring == "" ]]; then
            searchstring='.'
        fi
        selection=("${(@f)$(print -l $allfiles | ${=GREP} $searchstring)}")
        clear
        print -l $selection
        oldsearchstring="$searchstring"
        # vared is a very nifty function provided by zsh.
        vared -p 'What do you want to hear? Press enter if you are done. ' searchstring
        if [[ $oldsearchstring = $searchstring ]]; then
            allfiles=($selection)
            break
        fi
    done
elif [[ $searchstring == "" ]]; then
    # No searchstring given, that's a valid option too. Just play
    # something.
    :
elif ! allfiles=("${(@f)$(print -l $allfiles | ${=GREP} $searchstring)}"); then
    # Or a regex is given but no need to refine it.
    do_nothing="TRUE"
    error "Nothing found with that regexp."
fi

if [[ $all == "TRUE" ]]; then
    count=${#allfiles}
fi

holdcount="$count"
# Get through our list.
while ((count-- > 0)); do
    if [[ ${#allfiles} == 0 ]]; then
        print 'No more files to play.'
        break
    fi
    if [[ $nonrandom == "TRUE" ]]; then
        rndm=1
    else
        # The Pseudorandom $RANDOM is not random enough. All songs
        # from the same few artists gets annoying real quick.
        rndm=$(od -vAn -N4 -tu4 < /dev/urandom)
        # Mind the off by one.
        (((rndm %= ${#allfiles}) += 1))
    fi
    song="$allfiles[$rndm]"
    enqueue_song
    # Remove the current song from the playlist.
    allfiles[$rndm]=()
done

# Probably you want to start playing music if you get here and $0
# isn't running.
if [[ ! -f $pid_dir/pid ]] && [[ -s $play_queue ]]; then
    queue_mode
else
    if [[ $head == "TRUE" ]]; then
        WHERE=head
    else
        WHERE=bottom
    fi
    print "$holdcount songs added to the $WHERE of the play queue file."
    do_nothing="TRUE"
fi
